<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Algorithm.lean</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Lean4 v4.19.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">/-</span>
<span class="cm"> - Created in 2025 by GaÃ«tan SerrÃ©</span>
<span class="cm">-/</span>

<span class="kn">import</span> ConsistencyGO.Defs.Tuple
<span class="kn">import</span> Mathlib.MeasureTheory.Measure.Typeclasses.Probability
<span class="kn">import</span> Mathlib.Order.CompletePartialOrder

<span class="kn">open</span> MeasureTheory Tuple
<span class="sd">/--</span>
<span class="sd">Une maniÃ¨re de dÃ©finir un algorithme itÃ©ratif appliquÃ© Ã  une fonction serait de le</span>
<span class="sd">reprÃ©senter comme une mesure de probabilitÃ© sur les suites dans `Î©` : `Î½ : Measure (â„• â†’ Î©)`.</span>
<span class="sd">Cette mesure reprÃ©sente la distribution des suites d&#39;itÃ©rations produites par</span>
<span class="sd">l&#39;algorithme en temps infini. Cette dÃ©finition permet aussi Ã©tudier les sÃ©quences</span>
<span class="sd">d&#39;itÃ©rations finies : pour tout entier `n` et tout prÃ©dicat `P : (Fin n â†’ Î©) â†’ Prop`,</span>
<span class="sd">on peut mesurer l&#39;ensemble d&#39;itÃ©rations de taille `n` qui vÃ©rifie `P` :</span>
<span class="sd">`Î½ {u : â„• â†’ Î© | P (u[1:n])}`. Cette mesure `Î½` peut cependant s&#39;avÃ©rer difficile Ã </span>
<span class="sd">dÃ©finir. En effet, il est nÃ©cessaire de connaÃ®tre la distribution des limites des</span>
<span class="sd">sÃ©quences d&#39;itÃ©rations de l&#39;algorithme. Une maniÃ¨re plus simple de dÃ©finir un</span>
<span class="sd">algorithme itÃ©ratif serait de le reprÃ©senter par une suite de mesures de probabilitÃ©</span>
<span class="sd">`Î¼ : (n : â„•) â†’ Measure (Fin n â†’ Î©)`. Pour tout entier `n`, la mesure `Î¼ n` agit sur</span>
<span class="sd">l&#39;espace des sÃ©quences de longueur `n` et reprÃ©sente la distribution des `n` premiÃ¨res</span>
<span class="sd">itÃ©rations de l&#39;algorithme. Il est trÃ¨s simple de dÃ©finir `Î¼` Ã  partir de `Î½` :</span>
<span class="sd">`Î¼ = Î» n (s : Set (Fin n â†’ Î©)) â†¦ Î½ {u : â„• â†’ Î© | u[1:n] âˆˆ s}`. Ã€ partir de cette</span>
<span class="sd">dÃ©finition, il est trivial de montrer que</span>
<span class="sd">`Î¼ n {u : Fin n â†’ Î© | P u} = Î½ {u : â„• â†’ Î© | P (u[1:n])}`,</span>
<span class="sd">ce qui implique</span>
<span class="sd">`lim_(n â†’ âˆ) Î¼ n {u : Fin n â†’ Î© | P u} = lim_(n â†’ âˆ) Î½ {u : â„• â†’ Î© | P (u[1:n])}`</span>
<span class="sd">(voir `Utils.iff_convergence`).</span>
<span class="sd">Ainsi, `f g : (n : â„•) â†’ Fin n â†’ Î©` converge en mesure (par rapport Ã  `Î½`)</span>
<span class="sd">l&#39;une vers l&#39;autre si et seulement si</span>
<span class="sd">`âˆ€ Îµ &gt; 0, lim_(n â†’ âˆ) Î¼ n {u : Fin n â†’ Î© | |f n u - g n u| &gt; Îµ} = 0`.</span>
<span class="sd">L&#39;inconvÃ©nient de cette dÃ©finition est que l&#39;objet `Î¼ âˆ = Î½` n&#39;est pas</span>
<span class="sd">directement accessible : pour un prÃ©dicat `P` sur les suites, il sera nÃ©cessaire</span>
<span class="sd">de construire un prÃ©dicat `P&#39;` sur les sÃ©quences tel que</span>
<span class="sd">`lim_(n â†’ âˆ) Î¼ n {u : Fin n â†’ Omega | P&#39; u} = Î½ {u : â„• â†’ Î© | P u}`.</span>
<span class="sd">Cependant, dans la plupart des analyses de convergence d&#39;algorithmes itÃ©ratifs,</span>
<span class="sd">seul la convergence de mesure de prÃ©dicats sur les sÃ©quences d&#39;itÃ©rations est</span>
<span class="sd">Ã©tudiÃ©e. Ainsi, nous utiliserons la suite de mesures `Î¼ (n : â„•) â†’ Measure (Fin n â†’ Î©)`</span>
<span class="sd">pour reprÃ©senter un algorithme itÃ©ratif.</span>
<span class="sd">-/</span>
<span class="kd">structure</span> Algorithm (Î± Î² : <span class="kt">Type</span><span class="bp">*</span>) [MeasurableSpace Î±] [LinearOrder Î²] where
  Î¼ : (Î± <span class="bp">â†’</span> Î²) <span class="bp">â†’</span> (n : â„•) <span class="bp">â†’</span> Measure (Fin n <span class="bp">â†’</span> Î±)
  Î¼_prob : (f : Î± <span class="bp">â†’</span> Î²) <span class="bp">â†’</span> (n : â„•) <span class="bp">â†’</span> IsProbabilityMeasure (Î¼ f n)
  <span class="c">/-</span>
<span class="cm">  Ã‰quivalent Ã  dire que `âˆ€ n â‰¤ m, Î¼ f n A = Î¼ f m {u | u[1:n] âˆˆ A}`.</span>
<span class="cm">  -/</span>
  Î¼_mono : <span class="bp">âˆ€</span> (f : Î± <span class="bp">â†’</span> Î²), <span class="bp">âˆ€</span> â¦ƒn m A Bâ¦„,
      {u <span class="bp">|</span> toTuple n u <span class="bp">âˆˆ</span> A} <span class="bp">âŠ†</span> {u <span class="bp">|</span> toTuple m u <span class="bp">âˆˆ</span> B} <span class="bp">â†’</span> Î¼ f n A <span class="bp">â‰¤</span> Î¼ f m B
  <span class="c">/-</span>
<span class="cm">  Si deux fonctions sont indiscernables sur un ensemble `s`, alors la probabilitÃ©</span>
<span class="cm">  qu&#39;aucune itÃ©ration ne soit dans `sá¶œ` est Ã©gale pour les deux fonctions.</span>
<span class="cm">  En effet, comme l&#39;algorithme n&#39;a accÃ¨s qu&#39;aux Ã©valuations de la fonction,</span>
<span class="cm">  la distribution du i-Ã¨me point de la sÃ©quence d&#39;itÃ©rations dÃ©pend des points</span>
<span class="cm">  prÃ©cÃ©dent. Or, si aucun de ces points n&#39;est dans `sá¶œ` et que `f = g` sur `s`,</span>
<span class="cm">  alors la distribution du i-Ã¨me point est la mÃªme pour les deux fonctions. Ainsi,</span>
<span class="cm">  la distribution des sÃ©quences d&#39;itÃ©rations qui contiennent aucun point dans</span>
<span class="cm">  `sá¶œ` est la mÃªme pour les deux fonctions. Cependant, la distribution des sÃ©quences</span>
<span class="cm">  d&#39;itÃ©rations qui contiennent plus un point ou plus peuvent diffÃ©rer (par ex si `g` est</span>
<span class="cm">  minimisÃ© sur `sá¶œ`).</span>
<span class="cm">  -/</span>
  Î¼_eq_restrict : <span class="bp">âˆ€</span> â¦ƒf g : Î± <span class="bp">â†’</span> Î²â¦„, <span class="bp">âˆ€</span> â¦ƒs : Set Î±â¦„, (<span class="bp">âˆ€</span> a <span class="bp">âˆˆ</span> s, f a <span class="bp">=</span> g a) <span class="bp">â†’</span> <span class="bp">âˆ€</span> n,
      Î¼ f n {u <span class="bp">|</span> <span class="bp">âˆ€</span> i, u i <span class="bp">âˆ‰</span> s<span class="bp">á¶œ</span>} <span class="bp">=</span> Î¼ g n {u <span class="bp">|</span> <span class="bp">âˆ€</span> i, u i <span class="bp">âˆ‰</span> s<span class="bp">á¶œ</span>}
</span></pre></article></body></html>